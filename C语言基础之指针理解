1.什么是指针：
指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。

在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。

#include<stdio.h>

int main()

{

    char *str;

    printf("%p\n", str);

    printf("%d\n", sizeof(str));

    str = "I LOVE YOU";

    printf("%p\n", str);

    printf("%d\n", sizeof(str));

    int b[3]={1,2,3};

    printf("-------\n");

    int *pp;

    printf("%p\n", pp);

    printf("%d\n", sizeof(pp));

    pp = b;

    printf("%p\n", pp);

    printf("%p\n", b);

    printf("%d\n", sizeof(pp));

}

先声明几个指针放着做例子：

例一：

 

(1)int*ptr; 

(2)char*ptr; 

(3)int**ptr; 

(4)int(*ptr)[3]; 

(5)int*(*ptr)[4];

 

1.1 指针的类型
从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：

(1)int*ptr;//指针的类型是int*

(2)char*ptr;//指针的类型是char*

(3)int**ptr;//指针的类型是int**

(4)int(*ptr)[3];//指针的类型是int(*)[3]

(5)int*(*ptr)[4];//指针的类型是int*(*)[4]

怎么样？找出指针的类型的方法是不是很简单？

1.2.指针所指向的类型
当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

(1)int*ptr; //指针所指向的类型是int

(2)char*ptr; //指针所指向的的类型是char

(3)int**ptr; //指针所指向的的类型是int*

(4)int(*ptr)[3]; //指针所指向的的类型是int()[3]

(5)int*(*ptr)[4]; //指针所指向的的类型是int*()[4]

 

在指针的算术运算中，指针所指向的类型有很大的作用。

指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C 越来越熟悉时，你会发现，把与指针搅和在一起的"类型"这个概念分成"指针的类型"和"指针所指向的类型"两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。

1.3.指针的值----或者叫指针所指向的内存区或地址
指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的指针的值都是一个32 位整数，因为32 位程序里内存地址全都是32 位长。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

1.4 指针本身所占据的内存区
指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。

2.关键点：
每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）。

 

3.指针内存分配：
我们在刚刚接触指针的时候遇到过这样的情况，int *p；p=&a;这种方法不是指针的动态分配内存，这个叫做指针变量的初始化！初始化同样也可以让指针变量有方向可指。

int *p；p=malloc(n*sizeof(类型名称))；我们通过malloc（）函数为一个指针变量p分配了地址，这样我们从键盘上键入的值就这样存储在p里面了，接下来我们就可以对这个p进行具体的操作了，比如scanf（“%s”，p）等等。当我们对p结束操作的时候还要释放p的内存空间。为什么要释放内存空间呢？在上面我已经讲过动态分配的变量时储存在堆里面，但是这个堆的空间并不是无限大的，也许当我们编一个小的程序的时候可能我们并不能够发现什么，但是对于那些大的程序，如果我们没及时释放堆的空间的时候会放生内存泄露。

 

4 函数指针：
&是地址，函数和变量一样，函数前加&表示函数的入口地址，整体就是定义一个指针，并且在初始化的时候给一个具体的函数入口地址，可以直接调用。

    change(s, ss);

    printf("num a=%d\n num b=%d\n", a, b);

    printf("%p\n", change);

    printf("%p\n", &change);

 

两个输出的地址是一样的

注意：c语言中结构体名字并不是地址。

 

5 数组和指针：
C语言中，数组和指针本质上都是内存地址，都可以用[]做偏移。

 

6 指针的安全：
看下面的例子：

 

char s='a'; 

int *ptr; 

ptr=(int *)&s; 

*ptr=1298；

指针ptr 是一个int *类型的指针，它指向的类型是int。它指向的地址就是s 的首地址。在32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。

让我们再来看一例： 

char a; 

int *ptr=&a; 

ptr++; 

*ptr=115;

该例子完全可以通过编译，并能执行。但是看到没有？第3 句对指针ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。

而第4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。

在指针的强制类型转换：ptr1=(TYPE *)ptr2 中，如果sizeof(ptr2的类型)大于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。

 
