1.       有符号数和无符号数

正数和负数在计算机中的存储都是以二进制位的形式，但是对于正数来说直接存储即可，而负数则是以补码的形式存储的，负数在计算机中的存储最高位表示符号位（1：负数，0：正数）。

-7：

原码：1000 0111

反码：1111 1000（符号位不变其余位按位取反）

补码：1111 1001（反码+1）

举例：若A = 60，则

(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。

 

2.       运算符优先级

3.       函数声明

在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：

int max(int, int);

必须先声明吗？？？

为了不出问题还是先声明，或者函数写在main之前。

 

4.       编码问题

 

5.       数组作为参数传递时，

double getAverage(int *arr, int size)

在函数中可以有两种方式调用：

sum += *(arr+i);

sum += num[i];

6.       伪随机数

srand((unsigned)time(NULL))是初始化随机函数种子：

·          1、是拿当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列的。 所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。

·          2、使用时，参数可以是unsigned型的任意数据，比如srand（10）；

·          3、如果不使用srand，用rand（）产生的随机数，在多次运行，结果是一样的。

·         枚举，

枚举类型不连续，这种枚举无法遍历。枚举中的值默认的是前一个+1，int。

8.       输出：

 %p是打印地址的, %x是以十六进制形式打印

9.      数组名，本身是一个地址，如

char var2[10];

Var2和&var2是一样的

 

10.   指针

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr) /* 如果 p 非空，则完成 */ if(!ptr) /* 如果 p 为空，则完成 */

 

我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。

 

函数指针：

int (* p)(int, int) = & max; // &可以省略

其中max是定义的函数

int max(int x, int y)

11.   回调函数（到底谁是回调函数，调用者，还是被调用者）

函数指针作为某个函数的参数。

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

以下是来自知乎作者常溪玲的解说：

你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

12.   字符串：

字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。

strlen 是函数，sizeof 是运算操作符，二者得到的结果类型为 size_t，即 unsigned int 类型。

sizeof 计算的是变量的大小，不受字符 \0 影响；

而 strlen 计算的是字符串的长度，以 \0 作为长度判定依据。

 

13.   位域：（不太懂）

struct 位域结构名
{

位域列表

};

struct bs{ int a:8; int b:2; int c:6; }data;

位域在本质上就是一种结构类型，不过其成员是按二进位分配的。

一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。

那如果有9位呢？

还有位域里的类型是？

（1）结构体内存分配原则：

·         原则一：结构体中元素按照定义顺序存放到内存中，但并不是紧密排列。从结构体存储的首地址开始 ，每一个元素存入内存中时，它都会认为内存是以自己的宽度来划分空间的，因此元素存放的位置一定会在自己大小的整数倍上开始。

·         原则二： 在原则一的基础上，检查计算出的存储单元是否为所有元素中最宽的元素长度的整数倍。若是，则结束；否则，将其补齐为它的整数倍。

（2）定义位域时，各个成员的类型最好保持一致，比如都用char，或都用int，不要混合使用，这样才能达到节省内存空间的目的。

 

·         共用体：

使用union关键字

结构和定义类似于结构体，只是使用和内存不一样。共用体中的所有成员是公用内存的，大小是其中最大的成员的内存，后面的会把前面的值占用。

 

15.   define（预处理）

# define PI 3.14159

定义常量

定义函数   #define MAX(a,b) ((a) > (b) ? (a) : (b))

Typedef

typedef unsigned char uchar

为数据类型（可以是已有，也可以是用户自定义的）取个别名。

#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：

·         typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。

·         typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。【凡是以“#”开头的均为预处理指令】

 

·         输入与输出

C 语言把所有的设备都当作文件。【Linux中一切皆是文件】所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕：stdin，stdout，stderr。

scanf("%f",&f);

scanf("%s %d", str, &i);

另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

scanf() 函数返回的值为：正确按指定格式输入变量的个数；也即能正确接收到值的变量个数。

scanf("c1=%c",&c1);

输入多个数时，不要加空格。

输入：scanf，getchar，gets

输出：printf，putchar，puts

17.   文件处理：

一般流程是先打开文件（fopen）--读/写文件（与输入输出基本一致，加f）--处理--关闭文件（fclose）。

读文件是读到缓冲流中。

为什么读的时候是有记忆的？？？

 

18.   预处理器

#define 定义宏

#include

#undef

#ifdef

#if……#endif

#error

#pragma

19.   头文件

#include <file> 引用系统文件

#include "file" 引用用户头文件

只因用一次头文件（包装器）

#ifndef HEADER_FILE
#define HEADER_FILE

the entire header file file

#endif

 

建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。

20.   类型转换

double   <---    float
   ^
   |
   |
long
   ^
   |
unsigned
   ^
   |
int    <---   short,char

21.   内存管理

动态分配内存：

void *calloc(int num, int size);

void *malloc(int num); 

void *realloc(void *address, int newsize); （这个一般不要用）

如：

description = (char *)malloc( 200 * sizeof(char) );

释放内存：

void free(void *address); 

 

指针释放后要置null。

22.   Scanf

格式

字符意义

d

输入十进制整数

o

输入八进制整数

x

输入十六进制整数

u

输入无符号十进制整数

f或e

输入实型数(用小数形式或指数形式)

c

输入单个字符

s

输入字符串

ld

长整型

Lf

双精度浮点数

 

3、printf中%p的输出应用

%p表示输出以内存中实际存储一个变量格式（十六进制、32位（视机器的位数而定））的值，通常也就是地址的值，但也不一定，要看具体输出的是什么。
